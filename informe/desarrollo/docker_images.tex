%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%																				%
%	TRABAJO:	Trabajo Final													%
%				Especialidad en Ingeniería en Sistemas de Información			%
%																				%
%		Titulo:																	%
%																				%
%		Autor:	Julián Nonino													%
%																				%
%	Capitulo sobre las imágenes de Docker Creadas								%	
%																				%
%	Año: 2016																	%
%																				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstset
{	basicstyle=\tiny,       		% the size of the fonts that are used for the code
	numbers=left,                   % where to put the line-numbers
	numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
	stepnumber=1,                   % the step between two line-numbers. If it's 1, each line will be numbered
	numbersep=5pt,                  % how far the line-numbers are from the code
	showspaces=false,               % show spaces adding particular underscores
	showstringspaces=false,         % underline spaces within strings
	showtabs=false,                 % show tabs within strings adding particular underscores
	frame=none,                 	% adds a frame around the code
	rulecolor=\color{white},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	tabsize=2,                      % sets default tabsize to 2 spaces
	captionpos=b,                   % sets the caption-position to bottom
	breaklines=true,                % sets automatic line breaking
	breakatwhitespace=true,        	% sets if automatic breaks should only happen at
	keywordstyle=\color{blue},     	% keyword style
  	commentstyle=\color{dkgreen}, 	% comment style
  	stringstyle=\color{gray},      	% string literal style
  	escapeinside={\%*}{*)},         % if you want to add LaTeX within your code
  	morekeywords={*,apt-get,...},   % if you want to add more keywords to the set
  	deletekeywords={local,...}      % if you want to delete keywords from the given language
}

\chapter{Imágenes de Docker}
\label{chapter_docker_images}

El sistema desarrollado se compone de una serie de imágenes de Docker que al
ejecutarse como Docker Containers, formarán el sistema de procesamiento de datos
en tiempo real que se quiere demostrar. Las imágenes desarrolladas son:

\begin{itemize}
    \item Nodo de Zookeeper \ref{docker-image-nodo-zookeeper}
    \item Nodo de Kafka \ref{docker-image-nodo-kafka}
\end{itemize}

\section{Nodo Apache Zookeeper}
\label{docker-image-nodo-zookeeper}

	Basado en una imagen de Ubuntu 14.04 Trusty, se desarrolla la imagen de
	Apache Zookeeper.

	\lstinputlisting[language=Bash,
					 caption={Dockerfile para un nodo de Apache Zookeeper},
					 label=code_zookeeper_dockerfile
					]{./docker_images/zookeeper/Dockerfile.}
	
	Para comenzar, se realiza una actualización del sistema operativo y luego se
	procede con la instalación de Apache Zookeeper a través de la
	herramienta \emph{apt-get} de Ubuntu. Luego, se limpian todos los restos que
	hayan quedado de la instalación para reducir el tamaño de la imagen.
	Posteriormente, se exponen los puertos necesarios para la ejecución.
	
	Con eso ya se podría iniciar un único nodo de Apache Zookeeper agregando a la
	imagen el siguiente comando.
	
\lstset{language=Bash}
\begin{lstlisting}
CMD ["/usr/share/zookeeper/bin/zkServer.sh", "start-foreground"]
\end{lstlisting}

	Como se desea correr un clúster de Apache Zookeeper, se deben hacer ciertas
	configuraciones para que cada nodo pueda comunicarse con los demás. Por ésta
	razón se implementa el siguiente script.
	
	\lstinputlisting[language=Bash,
					 caption={Script de inicio para un nodo de Apache Zookeeper},
					 label=code_zookeeper_start_sh
					]{./docker_images/zookeeper/start.sh}

	Lo que hace el script \ref{code_zookeeper_start_sh} es recibir como parámetros
	una identificación para el nodo y una lista de todos los nodos y configura Apache
	Zookeeper con esos datos antes de iniciar el servicio. Se hace de ésta manera
	debido al alcance de ésta demostración, en producción debería utilizarse algún
	sistema de auto descubrimiento de servicios para que los nodos se encuentren
	automáticamente al levantarse.

	La construcción de ésta imagen, se realiza situado en la carpeta
	\emph{zookeeper} del repositorio, mediante el siguiente comando.
	
\lstset{language=Bash}
\begin{lstlisting}
docker build -t jnonino/zookeeper .
\end{lstlisting}

	Luego de construir la imagen de Zookeeper, el clúster de tres nodos puede ser
	lanzado mediante Docker Compose utilizando el siguiente comando:

\lstset{language=Bash}
\begin{lstlisting}
docker-compose -f start_zookeeper.yml up -d
\end{lstlisting}
	
	El comando anterior	inicia tres nodos de Zookeeper basados en la imagen
	construida anteriormente, el valor \emph{-d} al final indica que se desea que
	los containers corran en segundo plano.
	
	\lstinputlisting[language=Bash,
					 caption={Script de inicio de Docker Compose para levantar un clúster de
					 3 nodos de Apache Zookeeper},
					 label=code_zookeeper_compose
					 ]{./docker_images/zookeeper/start_zookeeper.yml}
	
	Notar que se utiliza la misma dirección IP para los tres nodos, ésto se debe a
	que para la demostración que se hace en éste trabajo, todos los servicios
	correran en un mismo servidor. Lógicamente, en un sistema en producción,
	atendiendo datos de clientes, dichos servicios deberían correr en instancias
	diferenciadas para garantizar la alta disponibilidad que Apache Zookeeper promete
	al utilizar más de un nodo.
	
	Para comprobar que los tres nodos están corriendo correctamente, ejecutar el
	siguiente comando:

\lstset{language=Bash}
\begin{lstlisting}
for i in {2181..2183}; do 
	echo mntr | nc <IP_DEL_HOST> $i | grep zk_followers ;
done
\end{lstlisting}	

	Se debe obtener un resultado como el siguiente mostrando que Zookeeper está
	corriendo y que hay dos nodos además del nodo líder.

\lstset{language=Bash}
\begin{lstlisting}
zk_followers	2
\end{lstlisting}

\section{Nodo de Apache Kafka}
\label{docker-image-nodo-kafka}

	De la misma manera que los nodos de Apache Zookeeper, ésta imagen es basada en la
	imagen Ubuntu 14.04 Trusty. Y, como primera medida, se procede a la actualización
	del sistema operativo.

	\lstinputlisting[language=Bash,
					 caption={Dockerfile para un nodo de Apache Kafka},
					 label=code_kafka_dockerfile
					]{./docker_images/kafka/Dockerfile.}
	
	En éste caso, se proceden a instalar herramientas como \emph{wget}, \emph{tar} y
	\emph{Java 7 JRE} necesarias para que corra Apache Kafka. Debido a que Kafka no
	puede ser instalado mediante \emph{apt-get}, es necesario descargar el archivo
	\emph{.tar}, descomprimirlo y ejecutarlo.
	
	Luego de configurar el nodo, es posible lanzar Kafka mediante un script utilizado
	para configurar variables antes de la ejecución.
	
	\lstinputlisting[language=Bash,
					 caption={Script de inicio para un nodo de Apache Kafka},
					 label=code_kafka_start_sh
					]{./docker_images/kafka/start.sh}

	La construcción de ésta imagen, se realiza situado en la carpeta \emph{kafka} del
	repositorio, mediante el siguiente comando.
	
\lstset{language=Bash}
\begin{lstlisting}
docker build -t jnonino/kafka .
\end{lstlisting}

	Luego de construir la imagen, el clúster de tres nodos puede ser lanzado mediante
	Docker Compose utilizando el siguiente comando: 

\lstset{language=Bash}
\begin{lstlisting}
docker-compose -f start_kafka.yml up -d
\end{lstlisting}
	
	El comando anterior	inicia tres nodos de Kafka basados en la imagen
	construida anteriormente, el valor \emph{-d} al final indica que se desea que
	los containers corran en segundo plano.
	
	\lstinputlisting[language=Bash,
					 caption={Script de inicio de Docker Compose para levantar un clúster de
					 3 nodos de Apache Kafka},
					 label=code_zookeeper_compose
					 ]{./docker_images/kafka/start_kafka.yml}
	
	Notar que se utiliza la misma dirección IP para los tres nodos, ésto se debe a
	que para la demostración que se hace en éste trabajo, todos los servicios
	correran en un mismo servidor. Lógicamente, en un sistema en producción,
	atendiendo datos de clientes, dichos servicios deberían correr en instancias
	diferenciadas para garantizar la alta disponibilidad que Apache Kafka promete
	al utilizar más de un nodo.
	
	Para comprobar que los tres nodos están corriendo correctamente, es necesario
	descargar Kafka para interactuar con el servidor corriendo\footnote{Descargar
	Apache Kafka desde https://www.apache.org Version 0.9.0.1 con Scala 2.11}.

	Correr los siguientes comandos para crear un tópico de prueba y obtener
	información del mismo:
	
\lstset{language=Bash}
\begin{lstlisting}
./bin/kafka-topics.sh --create --topic test --partitions 3 --zookeeper
192.168.0.104 --replication-factor 2
./bin/kafka-topics.sh --describe --topic test --zookeeper 192.168.0.104
\end{lstlisting}	

	\begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth]{./informe/desarrollo/img/kafka_creacion_topic}
	\end{figure}

	Para enviar datos al servidor de Kafka, se debe generar una lista de los nodos de
	Kafka (\emph{brokers}) para posteriormente enviarle mensajes y finalmente, con
	otra aplicación provista por Kafka, leerlos.

\lstset{language=Bash}
\begin{lstlisting}
BROKER_LIST=192.168.0.104:9092,192.168.0.104:9093,192.168.0.104:9094
/bin/kafka-console-producer.sh --topic test --broker-list="$BROKER_LIST"
./bin/kafka-console-consumer.sh --zookeeper 192.168.0.104 --topic test
--from-beginning
\end{lstlisting}

	\begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth]{./informe/desarrollo/img/kafka_w_r_topic}
	\end{figure}

\section{Apache Storm}
\label{docker-images-storm}

	También basada en una imagen de docker de Ubuntu 14.04 Trusty se crea la imagen
	base para todos los servicios de Storm. 
	Cada nodo de Storm debe correr dos aplicaciones \emph{storm-supervisor} y
	\emph{storm-logviewer}. Para correr ambos procesos en un container de Docker, se
	utiliza un sistema de control de procesos hecho en Python llamado
	\emph{supervisord}
	
	Es necesario correr tres servicios, \emph{Storm Nimbus}, \emph{Storm
	UI} y al menos un nodo \emph{Storm Supervisor}. Dado que los tres compartes
	muchas configuraciones, se crea una imagen base de Apache Storm de la cual
	derivarán los tres servicios necesarios.
	
	\lstinputlisting[language=Bash,
					 caption={Dockerfile para la imagen base de Storm},
					 label=code_storm_base_dockerfile
					]{./docker_images/storm/storm-base/Dockerfile.}

	Se comienza actualizando el sistema operativo, luego se instalan todas las
	herramientas necesarias como \emph{tar}, \emph{wget} y \emph{supervisord}. Como
	no es posible la instalación de Apache Storm desde la herramienta \emph{apt-get},
	se debe realizar un procedimiento similar al seguido con Apache Kafka.
	Por último, se copian varios archivos de configuración que son necesarios para la
	ejecución de supervisord y Apache Storm.

	\lstinputlisting[language=Bash,
					 caption={Archivo de configuración de Apache Storm storm.yaml},
					 label=code_storm_yaml
					]{./docker_images/storm/storm-base/storm.yaml}

	\lstinputlisting[language=Bash,
					 caption={Archivo de configuración de Apache Storm cluster.xml},
					 label=code_cluster_xml
					]{./docker_images/storm/storm-base/cluster.xml}
	
	\lstinputlisting[language=Bash,
					 caption={Archivo de configuración de SupervisorD config-supervisord.sh},
					 label=code_config_supervisord_sh
					]{./docker_images/storm/storm-base/config-supervisord.sh}
	
	\lstinputlisting[language=Bash,
					 caption={Script de inicio de Storm},
					 label=code_start_supervisor_sh
					]{./docker_images/storm/storm-base/start-supervisor.sh}
	
	\subsection{Storm Nimbus}
	
		\lstinputlisting[language=Bash,
					 caption={Dockerfile para la imagen de Storm Nimbus},
					 label=code_storm_nimbus_dockerfile
					]{./docker_images/storm/storm-nimbus/Dockerfile.}
	
	\subsection{Storm Supervisor}
	
		\lstinputlisting[language=Bash,
					 caption={Dockerfile para la imagen de Storm Supervisor},
					 label=code_storm_supervisor_dockerfile
					]{./docker_images/storm/storm-supervisor/Dockerfile.}
					
	\subsection{Storm UI}
	
		\lstinputlisting[language=Bash,
					 caption={Dockerfile para la imagen de Storm UI},
					 label=code_storm_ui_dockerfile
					]{./docker_images/storm/storm-ui/Dockerfile.}				
	
	\subsection{Iniciar Apache Storm}
	
			Finaliza la construcción de todas las imágenes anteriores, es posible
			poner a correr un servidor de Apache Storm utilizando el siguiente comando:

\lstset{language=Bash}
\begin{lstlisting}
docker-compose -f start_storm.yml up -d
\end{lstlisting}
	
	El comando anterior	inicia los tres servicios de Storm necesarios, Storm
	Nimbus, Storm Supervisor y Storm UI, el valor \emph{-d} al final indica que se
	desea que los containers corran en segundo plano.
	
	\lstinputlisting[language=Bash,
					 caption={Script de inicio de Docker Compose para levantar Apache Storm},
					 label=code_storm_compose
					 ]{./docker_images/storm/start_storm.yml}
	
	Luego, es posible comprobar el estado de Storm accediendo a la interfaz web
	"http://<DOCKER_HOST_IP>:8080".
	